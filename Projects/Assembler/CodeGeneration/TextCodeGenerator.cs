using Assembler.Common;
using Assembler.InstructionProcessing;
using Assembler.Output;
using Assembler.Util;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Assembler.CodeGeneration
{
   /// <summary>
   /// Class that generates the code for a .text segment instruction
   /// </summary>
   internal class TextCodeGenerator : ISegmentCodeGenerator
   {
      /// <summary>
      /// Creates an instance of the second-pass assembler,
      /// which generates the code in the .text segment.
      /// </summary>
      /// <param name="symbolTable">The symbol table generated by the first-pass parser.</param>
      /// <param name="procFactory">The instruction processor factory to retrieve code generator implementations from.</param>
      public TextCodeGenerator(ILogger logger, SymbolTable symbolTable, InstructionProcessorFactory procFactory)
      {
         m_Logger = logger;
         m_ParserFac = procFactory;
         m_SymTbl = symbolTable;
         m_CurrTextAddress = CommonConstants.BASE_TEXT_ADDRESS;
      }

      /// <summary>
      /// Generates code for a .text instruction in the file.
      /// </summary>
      /// <param name="asmLine">The line to parse.</param>
      /// <param name="objFile">The object file that will be written to.</param>
      /// <param name="currAlignment">The current specified alignment of the file. Unused for .text parsers.</param>
      public void GenerateCodeForSegment(LineData asmLine, BasicObjectFile objFile, int currAlignment)
      {
         // scan to the first instruction.
         // this could share the same line as a label, so split on ':' and ','
         string[] tokenizedStr = asmLine.Text.Split(new char[] { ',', ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
         bool foundInstruction = false;

         string instructionToken = string.Empty;
         for (int i = 0; i < tokenizedStr.Length && !foundInstruction; ++i)
         {
            string token = tokenizedStr[i].Trim();
            // we found our instruction. build a string from this token
            // to the end of the array.
            if (m_ParserFac.IsInstruction(token))
            {
               foundInstruction = true;
               instructionToken = token;
            }
         }

         if (foundInstruction)
         {
            // first, validate that the instruction is not the last token in the string.
            // try to parse the instruction parameters
            // get the substring starting at the index of the next character after the instruction
            string instSubstring = asmLine.Text.Substring(asmLine.Text.IndexOf(instructionToken) + instructionToken.Length);

            //split the substring at the comma to get the instruction parameters.
            string[] argTokens = instSubstring.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            // trim whitespace from the beginning and end of each token.
            argTokens = argTokens.Apply((str) => str.Trim()).ToArray();

            // find the parser for the instruction.
            IInstructionGenerator parser = m_ParserFac.GetProcessorForInstruction(instructionToken);

            // beq instructions should (hopefully) not generate multiple instructions..
            IEnumerable<int> generatedInstructions = parser.GenerateCodeForInstruction(m_CurrTextAddress, argTokens);
            
            var srcInfo = new SourceLineInformation(asmLine.LineNum, m_CurrTextAddress, asmLine.Text);
            objFile.AddSourceInformation(srcInfo);

            foreach (int generatedInstruction in generatedInstructions)
            {
               objFile.AddInstruction(generatedInstruction);
               m_CurrTextAddress += CommonConstants.BASE_INSTRUCTION_SIZE_BYTES;
            }

         }
         else
         {
            // if not an instruction (may be a symbol)
            // preprocesor instruction shouldn't bring us here.
            // make sure the user is not typing garbage.
            string symStr = tokenizedStr[0];
            if (!m_SymTbl.ContainsSymbol(symStr))
            {

               throw new AssemblyException(asmLine.LineNum, "Unknown instruction \"" + asmLine.Text + "\" found.");
            }
         }
      }

      private readonly ILogger m_Logger;
      private readonly SymbolTable m_SymTbl;
      private readonly InstructionProcessorFactory m_ParserFac;
      private int m_CurrTextAddress;
   }
}
