using Assembler.Common;
using Assembler.CodeGeneration.InstructionGenerators;
using Assembler.Output;
using Assembler.Util;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Assembler.CodeGeneration
{
    /// <summary>
    /// Class that generates the code for a .text segment instruction
    /// </summary>
    class TextCodeGenerator : ISegmentCodeGenerator
    {
        /// <summary>
        /// Creates an instance of the second-pass assembler,
        /// which generates the code in the .text segment.
        /// </summary>
        /// <param name="symbolTable">The symbol table generated by the first-pass parser.</param>
        public TextCodeGenerator(SymbolTable symbolTable)
        {
            m_ParserFac = new InstructionGeneratorFactory(symbolTable);
            m_CurrTextAddress = CommonConstants.BASE_TEXT_ADDRESS;

            // precalculate the nop instruction byte, since this should always be the same.
            IEnumerable<int> nopVals = new NopInstructionParser().ParseInstruction(0, new string[] { });
            System.Diagnostics.Debug.Assert(nopVals.Count() == 1);
            m_PrecalculatedNopInstruction = nopVals.ElementAt(0);
        }

        /// <summary>
        /// Generates code for a .text instruction in the file.
        /// </summary>
        /// <param name="asmLine">The line to parse.</param>
        /// <param name="objFile">The object file that will be written to.</param>
        /// <param name="currAlignment">The current specified alignment of the file.</param>
        public void GenerateCodeForSegment(LineData asmLine, BasicObjectFile objFile, int currAlignment)
        {
            // scan to the first instruction.
            // this could share the same line as a label, so split on ':' and ','
            string[] tokenizedStr = asmLine.Text.Split(new char[] { ',', ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
            bool foundInstruction = false;
            
            string instructionToken = string.Empty;
            for (int i = 0; i < tokenizedStr.Length && !foundInstruction; ++i)
            {
                string token = tokenizedStr[i].Trim();
                // we found our instruction. build a string from this token
                // to the end of the array.
                if (m_ParserFac.IsInstruction(token))
                {
                    foundInstruction = true;
                    instructionToken = token;
                }
            }

            if (foundInstruction)
            {

                // first, validate that the instruction is not the last token in the string.
                string instSubstring = string.Empty;
                if (asmLine.Text.IndexOf(instructionToken) + instructionToken.Length + 1 >= asmLine.Text.Length)
                {
                    throw new ArgumentException("Expected arguments after instruction token \"" + instructionToken + '\"');
                }

                // try to parse the instruction parameters
                // get the substring starting at the index of the next character after the instruction
                instSubstring = asmLine.Text.Substring(asmLine.Text.IndexOf(instructionToken) + instructionToken.Length);

                //split the substring at the comma to get the instruction parameters.
                string[] argTokens = instSubstring.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                // trim whitespace from the beginning and end of each token.
                argTokens = argTokens.Apply((str) => str.Trim()).ToArray();

                // find the parser for the instruction.
                IParser parser = m_ParserFac.GetParserForInstruction(instructionToken);

                // first, calculate the address of the next theoretical instruction while factoring in padding.
                int paddingSize = ParserCommon.GetNumPaddingBytes(CommonConstants.BASE_INSTRUCTION_SIZE_BYTES, currAlignment);

                // padding should always be a multiple of the instruction size.
                System.Diagnostics.Debug.Assert(paddingSize % CommonConstants.BASE_INSTRUCTION_SIZE_BYTES == 0);
                int nextInstructionAddress = m_CurrTextAddress + CommonConstants.BASE_INSTRUCTION_SIZE_BYTES + paddingSize;

                // beq instructions should (hopefully) not generate multiple instructions..
                IEnumerable<int> generatedInstructions = parser.ParseInstruction(nextInstructionAddress, argTokens);

                foreach (int generatedInstruction in generatedInstructions)
                {
                    objFile.AddInstruction(generatedInstruction);
                    m_CurrTextAddress += CommonConstants.BASE_INSTRUCTION_SIZE_BYTES;

                    // if padding is required at this point, insert a NOP instruction here.
                    for (int i = 0; i < paddingSize; i += CommonConstants.BASE_INSTRUCTION_SIZE_BYTES)
                    {
                        objFile.AddInstruction(m_PrecalculatedNopInstruction);
                        m_CurrTextAddress += CommonConstants.BASE_INSTRUCTION_SIZE_BYTES;
                    }

                }
               
            }
        }

        private readonly InstructionGeneratorFactory m_ParserFac;
        private readonly int m_PrecalculatedNopInstruction;
        private int m_CurrTextAddress;
    }
}
