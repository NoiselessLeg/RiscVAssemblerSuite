using Assembler.Common;
using Assembler.InstructionProcessing;
using Assembler.Output;
using Assembler.Util;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Assembler.CodeGeneration
{
    /// <summary>
    /// Class that generates the code for a .text segment instruction
    /// </summary>
    class TextCodeGenerator : ISegmentCodeGenerator
    {
        /// <summary>
        /// Creates an instance of the second-pass assembler,
        /// which generates the code in the .text segment.
        /// </summary>
        /// <param name="symbolTable">The symbol table generated by the first-pass parser.</param>
        /// <param name="procFactory">The instruction processor factory to retrieve code generator implementations from.</param>
        public TextCodeGenerator(SymbolTable symbolTable, InstructionProcessorFactory procFactory)
        {
            m_ParserFac = procFactory;
            m_CurrTextAddress = CommonConstants.BASE_TEXT_ADDRESS;
        }

        /// <summary>
        /// Generates code for a .text instruction in the file.
        /// </summary>
        /// <param name="asmLine">The line to parse.</param>
        /// <param name="objFile">The object file that will be written to.</param>
        /// <param name="currAlignment">The current specified alignment of the file. Unused for .text parsers.</param>
        public void GenerateCodeForSegment(LineData asmLine, BasicObjectFile objFile, int currAlignment)
        {
            // scan to the first instruction.
            // this could share the same line as a label, so split on ':' and ','
            string[] tokenizedStr = asmLine.Text.Split(new char[] { ',', ':', ' ' }, StringSplitOptions.RemoveEmptyEntries);
            bool foundInstruction = false;
            
            string instructionToken = string.Empty;
            for (int i = 0; i < tokenizedStr.Length && !foundInstruction; ++i)
            {
                string token = tokenizedStr[i].Trim();
                // we found our instruction. build a string from this token
                // to the end of the array.
                if (m_ParserFac.IsInstruction(token))
                {
                    foundInstruction = true;
                    instructionToken = token;
                }
            }

            if (foundInstruction)
            {
                // first, validate that the instruction is not the last token in the string.
                string instSubstring = string.Empty;
                if (asmLine.Text.IndexOf(instructionToken) + instructionToken.Length + 1 >= asmLine.Text.Length)
                {
                    throw new ArgumentException("Expected arguments after instruction token \"" + instructionToken + '\"');
                }

                // try to parse the instruction parameters
                // get the substring starting at the index of the next character after the instruction
                instSubstring = asmLine.Text.Substring(asmLine.Text.IndexOf(instructionToken) + instructionToken.Length);

                //split the substring at the comma to get the instruction parameters.
                string[] argTokens = instSubstring.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                // trim whitespace from the beginning and end of each token.
                argTokens = argTokens.Apply((str) => str.Trim()).ToArray();

                // find the parser for the instruction.
                IInstructionGenerator parser = m_ParserFac.GetProcessorForInstruction(instructionToken);
                int nextInstructionAddress = m_CurrTextAddress + CommonConstants.BASE_INSTRUCTION_SIZE_BYTES;

                // beq instructions should (hopefully) not generate multiple instructions..
                IEnumerable<int> generatedInstructions = parser.GenerateCodeForInstruction(nextInstructionAddress, argTokens);

                foreach (int generatedInstruction in generatedInstructions)
                {
                    objFile.AddInstruction(generatedInstruction);
                    m_CurrTextAddress += CommonConstants.BASE_INSTRUCTION_SIZE_BYTES;
                }
               
            }
        }

        private readonly InstructionProcessorFactory m_ParserFac;
        private int m_CurrTextAddress;
    }
}
